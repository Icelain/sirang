use crate::common::proto;
use crate::quic;

use super::config::RemoteConfig;
use bytes::Bytes;
use std::error::Error;
use tokio::net::{TcpListener, TcpStream};
use tokio::sync::mpsc::{channel, Sender};

pub async fn reverse_remote(
    config: RemoteConfig,
) -> Result<(), Box<dyn Error + Send + Sync + 'static>> {
    let mut quic_srv =
        quic::new_quic_server(config.address, &config.tls_cert, &config.tls_key).await?;

    while let Some(mut quic_conn) = quic_srv.accept().await {
        if let Ok(Some(quic_stream)) = quic_conn.accept_bidirectional_stream().await {
            let tcp_srv = match TcpListener::bind(config.tcp_address.unwrap()).await {
                Ok(srv) => srv,
                Err(e) => {
                    log::warn!("Tcp Listener could not be created: {e}");
                    continue;
                }
            };

            let connected_msg = proto::ProtoCommand::CONNECTED(config.address).serialize();
            if let Err(e) = quic_stream.send(connected_msg).await {
                log::warn!(
                    "Error while sending connect message to local reverse tunnel instance: {e}"
                );
                continue;
            }

            let (quic_stream_sender, quic_stream_receiver) = channel::<Bytes>(1);

            // handle tcp stream
            while let Ok((tcp_stream, tcp_addr)) = tcp_srv.accept().await {
                let buffer_size = config.buffer_size;
                tokio::spawn(handle_send(
                    tcp_stream,
                    quic_stream_sender.clone(),
                    buffer_size,
                ));
            }
        }
    }

    Ok(())
}

pub async fn handle_send(
    tcp_stream: TcpStream,
    quic_stream_sender: Sender<Bytes>,
    buffer_size: usize,
) {
    let mut buffer = Vec::with_capacity(buffer_size);

    loop {}
}
